# src/agents/quiz_generation_agent_optimized.py
# Agent t·ªëi ∆∞u cho vi·ªác sinh c√¢u h·ªèi v·ªõi ch·∫•t l∆∞·ª£ng chuy√™n nghi·ªáp

import logging
import json
import re
from typing import Dict, Any, List, Optional

from ..core.llm_provider import LLMProvider

logger = logging.getLogger(__name__)

class QuizGenerationAgentOptimized:
    """
    Agent t·ªëi ∆∞u cho vi·ªác sinh c√¢u h·ªèi ki·ªÉm tra v·ªõi ch·∫•t l∆∞·ª£ng chuy√™n nghi·ªáp.
    ƒê∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ t·∫°o c√¢u h·ªèi chi ti·∫øt v·ªõi gi·∫£i th√≠ch ƒë·∫ßy ƒë·ªß.
    """
    
    def __init__(self, llm_provider: LLMProvider):
        self.llm_provider = llm_provider
        self.generated_questions = []
        logger.info("‚úÖ QuizGenerationAgentOptimized ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o.")

    def generate_professional_questions(
        self, 
        content: str, 
        task_details: Dict[str, Any], 
        question_format: str = "multiple_choice"
    ) -> List[Dict[str, Any]]:
        """
        Sinh c√¢u h·ªèi chuy√™n nghi·ªáp v·ªõi format chi ti·∫øt v√† gi·∫£i th√≠ch ƒë·∫ßy ƒë·ªß.
        
        Args:
            content (str): N·ªôi dung t√†i li·ªáu ƒë·ªÉ t·∫°o c√¢u h·ªèi
            task_details (Dict): Chi ti·∫øt v·ªÅ task (t·ª´ k·∫ø ho·∫°ch)
            question_format (str): Lo·∫°i c√¢u h·ªèi (multiple_choice, essay, practical)
            
        Returns:
            List[Dict]: Danh s√°ch c√¢u h·ªèi v·ªõi format chuy√™n nghi·ªáp
        """
        logger.info(f"üéØ Sinh c√¢u h·ªèi chuy√™n nghi·ªáp cho: {task_details.get('section_title', 'Unknown')}")
        
        section_title = task_details.get('section_title', 'Ch∆∞∆°ng h·ªçc')
        num_questions = task_details.get('num_questions', 1)
        difficulty_level = task_details.get('difficulty_level', 'medium')
        learning_objectives = task_details.get('learning_objectives', [])
        question_types = task_details.get('question_types', ['tr·∫Øc nghi·ªám'])
        
        # Map difficulty sang ti·∫øng Vi·ªát
        difficulty_map = {
            "easy": "C∆° b·∫£n - Nh·∫≠n bi·∫øt v√† hi·ªÉu",
            "medium": "Trung b√¨nh - V·∫≠n d·ª•ng v√† ph√¢n t√≠ch", 
            "hard": "N√¢ng cao - ƒê√°nh gi√° v√† s√°ng t·∫°o"
        }
        difficulty_desc = difficulty_map.get(difficulty_level, difficulty_map["medium"])
        
        system_prompt = """
        B·∫°n l√† gi√°o vi√™n ƒë·∫°i h·ªçc chuy√™n nghi·ªáp v·ªõi 20 nƒÉm kinh nghi·ªám trong vi·ªác thi·∫øt k·∫ø ƒë·ªÅ thi ch·∫•t l∆∞·ª£ng cao.
        B·∫°n c√≥ kh·∫£ nƒÉng t·∫°o ra nh·ªØng c√¢u h·ªèi s√¢u s·∫Øc, khoa h·ªçc v√† ph√π h·ª£p v·ªõi m·ª•c ti√™u ƒë√°nh gi√°.

        NGUY√äN T·∫ÆC QUAN TR·ªåNG NH·∫§T:
        - CH·ªà t·∫°o c√¢u h·ªèi d·ª±a tr√™n N·ªòI DUNG H·ªåC LI·ªÜU ƒë∆∞·ª£c cung c·∫•p
        - KH√îNG ƒë∆∞·ª£c s·ª≠ d·ª•ng ki·∫øn th·ª©c b√™n ngo√†i t√†i li·ªáu
        - KH√îNG ƒë∆∞·ª£c t·∫°o c√¢u h·ªèi v·ªÅ ch·ªß ƒë·ªÅ kh√¥ng xu·∫•t hi·ªán trong n·ªôi dung
        - Ph·∫£i tr√≠ch d·∫´n ch√≠nh x√°c t·ª´ t√†i li·ªáu g·ªëc

        QUY T·∫ÆC NGHI√äM NG·∫∂T:
        - LU√îN LU√îN tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát
        - KH√îNG s·ª≠ d·ª•ng ti·∫øng Anh trong c√¢u h·ªèi tr·ª´ thu·∫≠t ng·ªØ chuy√™n m√¥n c√≥ trong t√†i li·ªáu
        - M·ªói c√¢u h·ªèi ph·∫£i c√≥ gi·∫£i th√≠ch chi ti·∫øt d·ª±a tr√™n n·ªôi dung t√†i li·ªáu
        - ƒê·∫£m b·∫£o t√≠nh ch√≠nh x√°c v·ªÅ m·∫∑t h·ªçc thu·∫≠t theo ƒë√∫ng t√†i li·ªáu
        """
        
        user_prompt = f"""
        ## NHI·ªÜM V·ª§: Thi·∫øt k·∫ø c√¢u h·ªèi ki·ªÉm tra chuy√™n nghi·ªáp

        ### TH√îNG TIN CH∆Ø∆†NG M·ª§C:
        **Ti√™u ƒë·ªÅ:** {section_title}
        **S·ªë l∆∞·ª£ng c√¢u h·ªèi:** {num_questions}
        **M·ª©c ƒë·ªô kh√≥:** {difficulty_desc}
        **Lo·∫°i c√¢u h·ªèi:** {', '.join(question_types)}
        **M·ª•c ti√™u ƒë√°nh gi√°:** {', '.join(learning_objectives) if learning_objectives else 'Ki·∫øn th·ª©c t·ªïng qu√°t'}

        ### Y√äU C·∫¶U CH·∫§T L∆Ø·ª¢NG CAO:
        1. **C√¢u h·ªèi r√µ r√†ng:** Kh√¥ng g√¢y nh·∫ßm l·∫´n, ƒëi th·∫≥ng v√†o v·∫•n ƒë·ªÅ
        2. **ƒê√°p √°n ch√≠nh x√°c:** ƒê√°p √°n ƒë√∫ng ph·∫£i ho√†n to√†n ch√≠nh x√°c v·ªÅ m·∫∑t khoa h·ªçc
        3. **Ph∆∞∆°ng √°n nhi·ªÖu h·ª£p l√Ω:** C√°c l·ª±a ch·ªçn sai ph·∫£i h·ª£p l√Ω, kh√¥ng qu√° d·ªÖ lo·∫°i tr·ª´
        4. **Gi·∫£i th√≠ch chi ti·∫øt:** M·ªói c√¢u ph·∫£i c√≥ gi·∫£i th√≠ch t·∫°i sao ƒë√°p √°n n√†y ƒë√∫ng v√† c√°c ƒë√°p √°n kh√°c sai

        ### ƒê·ªäNH D·∫†NG ƒê·∫¶U RA CHU·∫®N:
        ```json
        [
            {{
                "question_id": 1,
                "question_type": "multiple_choice",
                "question_text": "C√¢u h·ªèi chi ti·∫øt v√† r√µ r√†ng?",
                "options": {{
                    "A": "Ph∆∞∆°ng √°n A - m√¥ t·∫£ c·ª• th·ªÉ",
                    "B": "Ph∆∞∆°ng √°n B - m√¥ t·∫£ c·ª• th·ªÉ", 
                    "C": "Ph∆∞∆°ng √°n C - m√¥ t·∫£ c·ª• th·ªÉ",
                    "D": "Ph∆∞∆°ng √°n D - m√¥ t·∫£ c·ª• th·ªÉ"
                }},
                "correct_answer": "A",
                "explanation": {{
                    "correct_reason": "Gi·∫£i th√≠ch chi ti·∫øt t·∫°i sao ƒë√°p √°n A ƒë√∫ng, bao g·ªìm l√Ω thuy·∫øt n·ªÅn t·∫£ng v√† v√≠ d·ª• minh h·ªça.",
                    "incorrect_reasons": {{
                        "B": "L√Ω do t·∫°i sao ph∆∞∆°ng √°n B kh√¥ng ch√≠nh x√°c.",
                        "C": "L√Ω do t·∫°i sao ph∆∞∆°ng √°n C kh√¥ng ch√≠nh x√°c.",
                        "D": "L√Ω do t·∫°i sao ph∆∞∆°ng √°n D kh√¥ng ch√≠nh x√°c."
                    }}
                }},
                "difficulty": "{difficulty_level}",
                "topic": "{section_title}",
                "cognitive_level": "Nh·∫≠n bi·∫øt/Hi·ªÉu/V·∫≠n d·ª•ng/Ph√¢n t√≠ch/ƒê√°nh gi√°/S√°ng t·∫°o",
                "estimated_time": 2,
                "learning_objective": "M·ª•c ti√™u h·ªçc t·∫≠p c·ª• th·ªÉ ƒë∆∞·ª£c ƒë√°nh gi√°"
            }}
        ]
        ```

        ### H∆Ø·ªöNG D·∫™N T·∫†O C√ÇU H·ªéI:
        - C√¢u h·ªèi PH·∫¢I d·ª±a HO√ÄN TO√ÄN tr√™n n·ªôi dung h·ªçc li·ªáu ƒë∆∞·ª£c cung c·∫•p
        - KH√îNG ƒë∆∞·ª£c s·ª≠ d·ª•ng ki·∫øn th·ª©c b√™n ngo√†i t√†i li·ªáu
        - KH√îNG ƒë∆∞·ª£c t·∫°o c√¢u h·ªèi v·ªÅ ch·ªß ƒë·ªÅ kh√¥ng c√≥ trong n·ªôi dung
        - T·∫≠p trung v√†o c√°c kh√°i ni·ªám, ƒë·ªãnh nghƒ©a v√† th√¥ng tin c·ª• th·ªÉ trong t√†i li·ªáu
        - ƒê·∫£m b·∫£o t√≠nh ch√≠nh x√°c 100% theo n·ªôi dung g·ªëc

        ### N·ªòI DUNG H·ªåC LI·ªÜU:
        ```
        {content[:8000]}{"..." if len(content) > 8000 else ""}
        ```

        ### Y√äU C·∫¶U TH·ª∞C HI·ªÜN:
        1. ƒê·ªåC K·ª∏ to√†n b·ªô n·ªôi dung h·ªçc li·ªáu ƒë∆∞·ª£c cung c·∫•p
        2. CH·ªà t·∫°o c√¢u h·ªèi v·ªÅ nh·ªØng g√¨ c√≥ trong n·ªôi dung n√†y
        3. Tr√≠ch xu·∫•t c√°c kh√°i ni·ªám, ƒë·ªãnh nghƒ©a, nguy√™n l√Ω t·ª´ t√†i li·ªáu
        4. T·∫°o c√¢u h·ªèi ki·ªÉm tra hi·ªÉu bi·∫øt v·ªÅ n·ªôi dung ƒë√£ ƒë·ªçc
        5. Gi·∫£i th√≠ch d·ª±a tr√™n ch√≠nh x√°c nh·ªØng g√¨ c√≥ trong t√†i li·ªáu
        6. TUY·ªÜT ƒê·ªêI KH√îNG t·∫°o c√¢u h·ªèi v·ªÅ ki·∫øn th·ª©c ngo√†i t√†i li·ªáu

        ### NH·∫ÆC NH·ªû QUAN TR·ªåNG:
        - N·∫øu t√†i li·ªáu n√≥i v·ªÅ "Prompt Engineering", h√£y t·∫°o c√¢u h·ªèi v·ªÅ Prompt Engineering
        - N·∫øu t√†i li·ªáu n√≥i v·ªÅ "Machine Learning", h√£y t·∫°o c√¢u h·ªèi v·ªÅ Machine Learning  
        - KH√îNG t·∫°o c√¢u h·ªèi v·ªÅ ch·ªß ƒë·ªÅ kh√°c ngo√†i nh·ªØng g√¨ c√≥ trong t√†i li·ªáu

        ### K·∫æT QU·∫¢ (CH·ªà TR·∫¢ V·ªÄ JSON):
        """
        
        try:
            response = self.llm_provider.generate(
                system_prompt=system_prompt,
                user_prompt=user_prompt
            )
            
            # Tr√≠ch xu·∫•t v√† parse JSON
            questions_json = self._extract_json_from_response(response)
            questions = json.loads(questions_json)
            
            # Validate v√† clean up questions
            validated_questions = self._validate_and_clean_questions(questions, section_title)
            
            # L∆∞u v√†o cache
            self.generated_questions.extend(validated_questions)
            
            logger.info(f"‚úÖ ƒê√£ sinh {len(validated_questions)} c√¢u h·ªèi chuy√™n nghi·ªáp.")
            return validated_questions
            
        except json.JSONDecodeError as e:
            logger.error(f"L·ªói parse JSON c√¢u h·ªèi: {e}")
            return self._create_fallback_question(section_title, content)
        except Exception as e:
            logger.error(f"L·ªói khi sinh c√¢u h·ªèi: {e}")
            return self._create_fallback_question(section_title, content)

    def _extract_json_from_response(self, response: str) -> str:
        """Tr√≠ch xu·∫•t JSON t·ª´ response c·ªßa LLM."""
        # T√¨m JSON trong markdown code blocks
        json_patterns = [
            r'```json\s*(\[.*?\])\s*```',
            r'```\s*(\[.*?\])\s*```', 
            r'(\[.*?\])'
        ]
        
        for pattern in json_patterns:
            match = re.search(pattern, response, re.DOTALL)
            if match:
                return match.group(1)
        
        # N·∫øu kh√¥ng t√¨m th·∫•y, th·ª≠ to√†n b·ªô response
        return response.strip()

    def _validate_and_clean_questions(self, questions: List[Dict], section_title: str) -> List[Dict]:
        """Validate v√† l√†m s·∫°ch danh s√°ch c√¢u h·ªèi."""
        validated = []
        
        for i, q in enumerate(questions):
            try:
                # ƒê·∫£m b·∫£o c√≥ ƒë·ªß c√°c field b·∫Øt bu·ªôc
                required_fields = ['question_text', 'options', 'correct_answer', 'explanation']
                if not all(field in q for field in required_fields):
                    logger.warning(f"C√¢u h·ªèi {i+1} thi·∫øu field b·∫Øt bu·ªôc, b·ªè qua.")
                    continue
                
                # Validate options
                if not isinstance(q['options'], dict) or len(q['options']) < 2:
                    logger.warning(f"C√¢u h·ªèi {i+1} c√≥ options kh√¥ng h·ª£p l·ªá, b·ªè qua.")
                    continue
                
                # ƒê·∫£m b·∫£o correct_answer h·ª£p l·ªá
                if q['correct_answer'] not in q['options']:
                    logger.warning(f"C√¢u h·ªèi {i+1} c√≥ correct_answer kh√¥ng kh·ªõp v·ªõi options, b·ªè qua.")
                    continue
                
                # Th√™m c√°c field m·∫∑c ƒë·ªãnh n·∫øu thi·∫øu
                q.setdefault('question_id', i + 1)
                q.setdefault('question_type', 'multiple_choice')
                q.setdefault('difficulty', 'medium')
                q.setdefault('topic', section_title)
                q.setdefault('cognitive_level', 'Hi·ªÉu')
                q.setdefault('estimated_time', 2)
                q.setdefault('learning_objective', f'Ki·∫øn th·ª©c v·ªÅ {section_title}')
                
                validated.append(q)
                
            except Exception as e:
                logger.error(f"L·ªói khi validate c√¢u h·ªèi {i+1}: {e}")
                continue
        
        return validated

    def _create_fallback_question(self, section_title: str, content: str) -> List[Dict]:
        """T·∫°o c√¢u h·ªèi d·ª± ph√≤ng khi c√≥ l·ªói."""
        return [
            {
                "question_id": 1,
                "question_type": "multiple_choice",
                "question_text": f"Theo n·ªôi dung ƒë√£ h·ªçc v·ªÅ {section_title}, kh√°i ni·ªám n√†o sau ƒë√¢y l√† quan tr·ªçng nh·∫•t?",
                "options": {
                    "A": "Kh√°i ni·ªám c∆° b·∫£n trong l√Ω thuy·∫øt",
                    "B": "·ª®ng d·ª•ng th·ª±c t·∫ø trong c√¥ng vi·ªác", 
                    "C": "Ph∆∞∆°ng ph√°p ti·∫øp c·∫≠n v·∫•n ƒë·ªÅ",
                    "D": "T·∫•t c·∫£ c√°c kh√°i ni·ªám tr√™n"
                },
                "correct_answer": "D",
                "explanation": {
                    "correct_reason": f"Trong {section_title}, t·∫•t c·∫£ c√°c kh√≠a c·∫°nh ƒë·ªÅu quan tr·ªçng v√† b·ªï sung cho nhau.",
                    "incorrect_reasons": {
                        "A": "Ch·ªâ t·∫≠p trung v√†o l√Ω thuy·∫øt l√† ch∆∞a ƒë·ªß.",
                        "B": "Ch·ªâ t·∫≠p trung v√†o ·ª©ng d·ª•ng m√† thi·∫øu n·ªÅn t·∫£ng l√Ω thuy·∫øt l√† kh√¥ng ƒë·∫ßy ƒë·ªß.",
                        "C": "Ph∆∞∆°ng ph√°p quan tr·ªçng nh∆∞ng c·∫ßn k·∫øt h·ª£p v·ªõi ki·∫øn th·ª©c c∆° b·∫£n."
                    }
                },
                "difficulty": "medium",
                "topic": section_title,
                "cognitive_level": "Hi·ªÉu",
                "estimated_time": 2,
                "learning_objective": f"Hi·ªÉu t·ªïng quan v·ªÅ {section_title}"
            }
        ]

    def generate_essay_questions(
        self, 
        content: str, 
        task_details: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Sinh c√¢u h·ªèi t·ª± lu·∫≠n chuy√™n nghi·ªáp v·ªõi ti√™u ch√≠ ch·∫•m ƒëi·ªÉm chi ti·∫øt.
        """
        logger.info("üìù Sinh c√¢u h·ªèi t·ª± lu·∫≠n chuy√™n nghi·ªáp...")
        
        section_title = task_details.get('section_title', 'Ch∆∞∆°ng h·ªçc')
        num_questions = task_details.get('num_questions', 1)
        difficulty_level = task_details.get('difficulty_level', 'medium')
        
        system_prompt = """
        B·∫°n l√† gi√°o vi√™n ƒë·∫°i h·ªçc chuy√™n nghi·ªáp thi·∫øt k·∫ø c√¢u h·ªèi t·ª± lu·∫≠n ch·∫•t l∆∞·ª£ng cao.
        B·∫°n c√≥ kh·∫£ nƒÉng t·∫°o ra nh·ªØng c√¢u h·ªèi s√¢u s·∫Øc v√† ti√™u ch√≠ ƒë√°nh gi√° khoa h·ªçc.

        NGUY√äN T·∫ÆC QUAN TR·ªåNG NH·∫§T:
        - CH·ªà t·∫°o c√¢u h·ªèi d·ª±a tr√™n N·ªòI DUNG H·ªåC LI·ªÜU ƒë∆∞·ª£c cung c·∫•p
        - KH√îNG ƒë∆∞·ª£c s·ª≠ d·ª•ng ki·∫øn th·ª©c b√™n ngo√†i t√†i li·ªáu
        - C√¢u h·ªèi ph·∫£i ki·ªÉm tra hi·ªÉu bi·∫øt v·ªÅ n·ªôi dung ƒë√£ h·ªçc

        QUY T·∫ÆC: LU√îN tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát.
        """
        
        user_prompt = f"""
        ## NHI·ªÜM V·ª§: Thi·∫øt k·∫ø c√¢u h·ªèi t·ª± lu·∫≠n chuy√™n nghi·ªáp

        ### TH√îNG TIN:
        - Ch∆∞∆°ng m·ª•c: {section_title}
        - S·ªë c√¢u h·ªèi: {num_questions}
        - M·ª©c ƒë·ªô: {difficulty_level}

        ### ƒê·ªäNH D·∫†NG ƒê·∫¶U RA:
        ```json
        [
            {{
                "question_id": 1,
                "question_type": "essay",
                "question_text": "C√¢u h·ªèi t·ª± lu·∫≠n chi ti·∫øt...",
                "expected_length": "200-300 t·ª´",
                "scoring_criteria": {{
                    "content_accuracy": "Ti√™u ch√≠ v·ªÅ ƒë·ªô ch√≠nh x√°c n·ªôi dung (30%)",
                    "logical_structure": "Ti√™u ch√≠ v·ªÅ c·∫•u tr√∫c logic (25%)",
                    "examples_application": "Ti√™u ch√≠ v·ªÅ v√≠ d·ª• v√† ·ª©ng d·ª•ng (25%)",
                    "language_presentation": "Ti√™u ch√≠ v·ªÅ ng√¥n ng·ªØ v√† tr√¨nh b√†y (20%)"
                }},
                "sample_answer": "C√¢u tr·∫£ l·ªùi m·∫´u chi ti·∫øt...",
                "common_mistakes": ["L·ªói th∆∞·ªùng g·∫∑p 1", "L·ªói th∆∞·ªùng g·∫∑p 2"],
                "difficulty": "{difficulty_level}",
                "topic": "{section_title}",
                "estimated_time": 15
            }}
        ]
        ```

        ### N·ªòI DUNG:
        {content[:6000]}...

        T·∫°o c√¢u h·ªèi t·ª± lu·∫≠n s√¢u s·∫Øc v·ªõi ti√™u ch√≠ ch·∫•m ƒëi·ªÉm chi ti·∫øt.
        """
        
        try:
            response = self.llm_provider.generate(system_prompt=system_prompt, user_prompt=user_prompt)
            questions_json = self._extract_json_from_response(response)
            questions = json.loads(questions_json)
            
            # Validate essay questions
            for q in questions:
                q.setdefault('question_type', 'essay')
                q.setdefault('estimated_time', 15)
            
            logger.info(f"‚úÖ ƒê√£ sinh {len(questions)} c√¢u h·ªèi t·ª± lu·∫≠n.")
            return questions
            
        except Exception as e:
            logger.error(f"L·ªói khi sinh c√¢u h·ªèi t·ª± lu·∫≠n: {e}")
            return []

    def format_quiz_for_export(self, questions: List[Dict], quiz_metadata: Dict = None) -> Dict[str, Any]:
        """
        Format c√¢u h·ªèi ƒë·ªÉ xu·∫•t file ho·∫∑c hi·ªÉn th·ªã.
        
        Args:
            questions (List[Dict]): Danh s√°ch c√¢u h·ªèi
            quiz_metadata (Dict): Th√¥ng tin meta v·ªÅ b·ªô ƒë·ªÅ
            
        Returns:
            Dict: B·ªô ƒë·ªÅ ƒë∆∞·ª£c format ho√†n ch·ªânh
        """
        logger.info("üìÑ Format b·ªô ƒë·ªÅ ƒë·ªÉ xu·∫•t file...")
        
        if not quiz_metadata:
            quiz_metadata = {
                "title": "B·ªô C√¢u H·ªèi Ki·ªÉm Tra",
                "description": "ƒê∆∞·ª£c t·∫°o b·ªüi AI Assistant",
                "total_questions": len(questions),
                "estimated_time": sum(q.get('estimated_time', 2) for q in questions),
                "difficulty_distribution": self._calculate_difficulty_distribution(questions)
            }
        
        formatted_quiz = {
            "quiz_metadata": quiz_metadata,
            "instructions": {
                "general": "ƒê·ªçc k·ªπ c√¢u h·ªèi tr∆∞·ªõc khi tr·∫£ l·ªùi. Ch·ªçn ƒë√°p √°n ƒë√∫ng nh·∫•t.",
                "time_limit": f"{quiz_metadata.get('estimated_time', 30)} ph√∫t",
                "scoring": "M·ªói c√¢u ƒë√∫ng ƒë∆∞·ª£c 1 ƒëi·ªÉm, c√¢u sai kh√¥ng b·ªã tr·ª´ ƒëi·ªÉm."
            },
            "questions": questions,
            "answer_key": self._generate_answer_key(questions),
            "statistics": {
                "total_questions": len(questions),
                "question_types": self._count_question_types(questions),
                "topics_covered": list(set(q.get('topic', 'Unknown') for q in questions)),
                "cognitive_levels": self._count_cognitive_levels(questions)
            }
        }
        
        return formatted_quiz

    def _calculate_difficulty_distribution(self, questions: List[Dict]) -> Dict[str, int]:
        """T√≠nh ph√¢n b·ªë ƒë·ªô kh√≥ c·ªßa c√¢u h·ªèi."""
        distribution = {"easy": 0, "medium": 0, "hard": 0}
        for q in questions:
            difficulty = q.get('difficulty', 'medium')
            if difficulty in distribution:
                distribution[difficulty] += 1
        return distribution

    def _count_question_types(self, questions: List[Dict]) -> Dict[str, int]:
        """ƒê·∫øm s·ªë l∆∞·ª£ng t·ª´ng lo·∫°i c√¢u h·ªèi."""
        types = {}
        for q in questions:
            q_type = q.get('question_type', 'multiple_choice')
            types[q_type] = types.get(q_type, 0) + 1
        return types

    def _count_cognitive_levels(self, questions: List[Dict]) -> Dict[str, int]:
        """ƒê·∫øm s·ªë l∆∞·ª£ng c√¢u h·ªèi theo c·∫•p ƒë·ªô nh·∫≠n th·ª©c."""
        levels = {}
        for q in questions:
            level = q.get('cognitive_level', 'Hi·ªÉu')
            levels[level] = levels.get(level, 0) + 1
        return levels

    def _generate_answer_key(self, questions: List[Dict]) -> List[Dict]:
        """T·∫°o ƒë√°p √°n cho b·ªô ƒë·ªÅ."""
        answer_key = []
        for q in questions:
            if q.get('question_type') == 'multiple_choice':
                answer_key.append({
                    "question_id": q.get('question_id'),
                    "correct_answer": q.get('correct_answer'),
                    "explanation": q.get('explanation', {}).get('correct_reason', 'Kh√¥ng c√≥ gi·∫£i th√≠ch')
                })
            elif q.get('question_type') == 'essay':
                answer_key.append({
                    "question_id": q.get('question_id'),
                    "sample_answer": q.get('sample_answer', 'Kh√¥ng c√≥ c√¢u tr·∫£ l·ªùi m·∫´u'),
                    "scoring_criteria": q.get('scoring_criteria', {})
                })
        return answer_key

    def get_generation_statistics(self) -> Dict[str, Any]:
        """L·∫•y th·ªëng k√™ v·ªÅ qu√° tr√¨nh sinh c√¢u h·ªèi."""
        if not self.generated_questions:
            return {"message": "Ch∆∞a c√≥ c√¢u h·ªèi n√†o ƒë∆∞·ª£c sinh"}
        
        return {
            "total_generated": len(self.generated_questions),
            "types": self._count_question_types(self.generated_questions),
            "difficulties": self._calculate_difficulty_distribution(self.generated_questions),
            "topics": list(set(q.get('topic', 'Unknown') for q in self.generated_questions)),
            "average_time": sum(q.get('estimated_time', 2) for q in self.generated_questions) / len(self.generated_questions)
        }

    # Compatibility methods ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi code c≈©
    def generate_quiz(self, document_id: int, user_request: str) -> str:
        """
        Method t∆∞∆°ng th√≠ch v·ªõi interface c≈© ƒë·ªÉ kh√¥ng ph√° v·ª° existing code.
        """
        logger.info(f"üîÑ Compatibility mode: generate_quiz for document {document_id}")
        
        try:
            # Parse user request ƒë·ªÉ l·∫•y th√¥ng tin
            num_questions = self._extract_number_from_request(user_request)
            difficulty = self._extract_difficulty_from_request(user_request)
            
            # T·∫°o sample content ƒë·ªÉ demo
            sample_content = """
            N·ªôi dung t√†i li·ªáu h·ªçc thu·∫≠t v·ªõi c√°c kh√°i ni·ªám quan tr·ªçng.
            Bao g·ªìm l√Ω thuy·∫øt c∆° b·∫£n, ·ª©ng d·ª•ng th·ª±c t·∫ø v√† ph∆∞∆°ng ph√°p ti·∫øp c·∫≠n.
            """
            
            # T·∫°o task details
            task_details = {
                'section_title': 'Ki·∫øn th·ª©c t·ªïng qu√°t',
                'num_questions': min(num_questions, 5),  # Gi·ªõi h·∫°n 5 c√¢u ƒë·ªÉ demo
                'question_types': ['tr·∫Øc nghi·ªám'],
                'difficulty_level': difficulty,
                'learning_objectives': ['Ki·ªÉm tra hi·ªÉu bi·∫øt c∆° b·∫£n'],
                'estimation_time': num_questions * 2
            }
            
            # Sinh c√¢u h·ªèi
            questions = self.generate_professional_questions(sample_content, task_details)
            
            if not questions:
                return "‚ùå Kh√¥ng th·ªÉ t·∫°o c√¢u h·ªèi. Vui l√≤ng th·ª≠ l·∫°i."
            
            # Format output
            return self._format_quiz_output(questions, user_request)
            
        except Exception as e:
            logger.error(f"L·ªói trong compatibility mode: {e}")
            return f"‚ùå L·ªói khi t·∫°o quiz: {str(e)}"

    def _extract_number_from_request(self, request: str) -> int:
        """Tr√≠ch xu·∫•t s·ªë c√¢u h·ªèi t·ª´ user request."""
        import re
        match = re.search(r'(\d+)\s*c√¢u', request.lower())
        return int(match.group(1)) if match else 3

    def _extract_difficulty_from_request(self, request: str) -> str:
        """Tr√≠ch xu·∫•t ƒë·ªô kh√≥ t·ª´ user request."""
        request_lower = request.lower()
        if 'd·ªÖ' in request_lower or 'easy' in request_lower:
            return 'easy'
        elif 'kh√≥' in request_lower or 'hard' in request_lower:
            return 'hard'
        else:
            return 'medium'

    def _format_quiz_output(self, questions: List[Dict], user_request: str) -> str:
        """Format output cho compatibility mode."""
        output = f"üéâ **B·ªò ƒê·ªÄ KI·ªÇM TRA ƒê√É T·∫†O XONG** üéâ\n"
        output += f"üìã **Y√™u c·∫ßu:** {user_request}\n"
        output += f"üìä **S·ªë c√¢u h·ªèi:** {len(questions)}\n\n"
        output += "="*60 + "\n\n"
        
        for i, question in enumerate(questions):
            output += f"**C√ÇU H·ªéI {i+1}:** {question.get('question_text', 'Kh√¥ng c√≥ c√¢u h·ªèi')}\n\n"
            
            # Hi·ªÉn th·ªã options
            for key, value in question.get('options', {}).items():
                marker = "‚úì" if key == question.get('correct_answer') else " "
                output += f"   {key}) {value} {marker}\n"
            
            output += f"\n**üí° Gi·∫£i th√≠ch:** {question.get('explanation', {}).get('correct_reason', 'Kh√¥ng c√≥ gi·∫£i th√≠ch')}\n"
            output += f"**‚è±Ô∏è Th·ªùi gian:** {question.get('estimated_time', 2)} ph√∫t\n"
            output += f"**üìà M·ª©c ƒë·ªô:** {question.get('difficulty', 'medium')}\n"
            output += "\n" + "-"*50 + "\n\n"
        
        return output